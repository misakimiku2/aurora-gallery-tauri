# 图片对比信息存储方案改进

## 背景

当前的 `.aurora` 文件存储方案存在以下问题：
1. 只保存图片的文件路径，如果图片被移动或删除，对比信息就会丢失
2. 不保存画布的视图状态（缩放比例、位移等）
3. 使用纯 JSON 格式，文件体积较大

## 改进目标

1. 将图片原始文件嵌入到 `.aurora` 文件中
2. 保存画布视图状态（缩放比例、位移）
3. 使用 ZIP 压缩格式减小文件体积
4. 保持 `.aurora` 文件扩展名不变
5. 向后兼容旧版本格式

## 实现方案

### 1. 新的文件结构（ZIP 格式）

```
xxx.aurora (ZIP文件)
├── manifest.json      # 版本、创建时间、会话名称
├── viewport.json      # 画布缩放比例、X/Y位移
├── layout.json        # 图片布局、注释、层级顺序
└── images/            # 图片文件夹
    ├── img_0.png
    ├── img_1.jpg
    └── ...
```

### 2. 类型定义更新

```typescript
// V2 版本：ZIP 格式存储
export interface ComparisonSessionManifest {
    version: '2.0';
    createdAt: number;
    sessionName: string;
}

export interface ComparisonSessionViewport {
    scale: number;
    x: number;
    y: number;
}

export interface ComparisonSessionLayout {
    items: {
        id: string;
        path: string;
        x: number;
        y: number;
        width: number;
        height: number;
        rotation: number;
        imageFileName: string; // ZIP 中的图片文件名
    }[];
    annotations: Annotation[];
    zOrder: string[];
}
```

### 3. 保存逻辑

使用 JSZip 库创建 ZIP 文件：

```typescript
const handleSaveSession = async () => {
  const zip = new JSZip();
  
  // 1. 添加 manifest.json
  const manifest: ComparisonSessionManifest = {
    version: '2.0',
    createdAt: Date.now(),
    sessionName
  };
  zip.file('manifest.json', JSON.stringify(manifest));
  
  // 2. 添加 viewport.json
  const viewport: ComparisonSessionViewport = {
    scale: transform.scale,
    x: transform.x,
    y: transform.y
  };
  zip.file('viewport.json', JSON.stringify(viewport));
  
  // 3. 添加图片到 images/ 文件夹
  const imagesFolder = zip.folder('images');
  // ... 读取图片数据并添加
  
  // 4. 添加 layout.json
  zip.file('layout.json', JSON.stringify(layoutData));
  
  // 5. 生成 ZIP 并保存
  const zipBlob = await zip.generateAsync({ type: 'uint8array' });
  await writeFile(path, zipBlob);
};
```

### 4. 加载逻辑

支持 v1.0（旧格式）和 v2.0（新格式）：

```typescript
const handleLoadSession = async () => {
  // 检测文件格式
  let isZipFormat = false;
  try {
    const textContent = await readTextFile(path);
    const parsed = JSON.parse(textContent);
    if (parsed.version && parsed.items) {
      // 处理旧格式 (v1.0)
      await loadLegacySession(parsed);
      return;
    }
  } catch {
    isZipFormat = true;
  }
  
  if (isZipFormat) {
    // 读取 ZIP 格式 (v2.0)
    const zipBytes = await readFile(path);
    const zip = await JSZip.loadAsync(zipBytes);
    // ... 解压并恢复状态
  }
};
```

## 遇到的问题及解决方案

### 问题 1：Tauri 文件系统权限限制

**现象**：使用 `@tauri-apps/plugin-fs` 的 `readFile` 读取图片时提示 `forbidden path`

**错误信息**：
```
forbidden path: E:/资源/xxx.png, maybe it is not allowed on the scope for `allow-read-file` permission in your capability file
```

**尝试的解决方案**：

1. **更新权限配置** (`src-tauri/capabilities/default.json`)
   ```json
   {
     "identifier": "fs:scope",
     "allowPaths": ["**"]
   }
   ```
   **结果**：仍然失败

2. **添加更多权限**
   ```json
   "fs:read-files",
   "fs:write-files"
   ```
   **结果**：仍然失败

3. **使用 `fetch` + `convertFileSrc`**
   ```typescript
   const imageUrl = convertFileSrc(file.path);
   const response = await fetch(imageUrl);
   const arrayBuffer = await response.arrayBuffer();
   ```
   **结果**：`TypeError: Failed to fetch`

4. **使用 `fetch` + `no-cors` 模式**
   ```typescript
   const response = await fetch(imageUrl, { mode: 'no-cors' });
   ```
   **结果**：`response.ok` 为 false，无法获取数据

5. **使用 XMLHttpRequest**
   ```typescript
   const xhr = new XMLHttpRequest();
   xhr.open('GET', imageUrl, true);
   xhr.responseType = 'arraybuffer';
   ```
   **结果**：`Error: XHR failed`

6. **使用 Canvas 导出（CORS 问题）**
   ```typescript
   const canvas = document.createElement('canvas');
   ctx.drawImage(cache.original, 0, 0);
   const dataUrl = canvas.toDataURL('image/png');
   ```
   **结果**：`SecurityError: Tainted canvases may not be exported`

7. **使用 Tauri Rust 后端命令（最终方案）**
   
   发现项目中已有 `read_file_as_base64` 命令：
   ```rust
   #[tauri::command]
   async fn read_file_as_base64(file_path: String) -> Result<Option<String>, String> {
       // ... 使用 std::fs::read 读取文件并返回 base64
   }
   ```
   
   前端调用：
   ```typescript
   import { invoke } from '@tauri-apps/api/core';
   
   const base64Data = await invoke<string>('read_file_as_base64', { filePath: file.path });
   // 注意：返回的是 Data URL 格式 data:image/png;base64,xxxx
   // 需要先提取纯 base64 部分
   const base64Content = base64Data.includes(',') 
       ? base64Data.split(',')[1] 
       : base64Data;
   const imageBytes = Uint8Array.from(atob(base64Content), c => c.charCodeAt(0));
   ```
   
   **结果**：✅ 已解决。注意前端需要处理 Data URL 格式，提取纯 base64 部分。

### 问题 2：文件加载问题

**现象**：读取 `.aurora` 文件时提示 `readFile is not defined`

**错误信息**：
```
ReferenceError: readFile is not defined
    at handleLoadSession (ImageComparer.tsx:1030:28)
```

**原因**：`handleLoadSession` 函数中使用了 `readFile`，但没有从 `@tauri-apps/plugin-fs` 导入

**解决方案**：
```typescript
// 修改前
import { writeTextFile, readTextFile, writeFile } from '@tauri-apps/plugin-fs';

// 修改后
import { writeTextFile, readTextFile, writeFile, readFile } from '@tauri-apps/plugin-fs';
```

**结果**：✅ 已解决

### 问题 3：加载时画布自适应缩放

**现象**：读取 `.aurora` 文件后，画布没有自动缩放到适应窗口的位置

**需求**：加载时保留图片的位移、旋转、缩放等变换信息，但让整个画布内容自适应窗口

**解决方案**：
1. 创建 `resetViewportOnly()` 函数，只重置画布视图，不重置图片变换
2. 添加 `shouldAutoFitAfterLoadRef` ref 标记需要自适应缩放
3. 使用 useEffect 监听 layout 变化，在布局计算完成后执行自适应缩放

```typescript
// 只重置画布视图，不重置图片变换
const resetViewportOnly = () => {
  if (layout.totalWidth > 0 && containerSize.width > 0) {
    const padding = 60;
    const scaleX = (containerSize.width - padding * 2) / layout.totalWidth;
    const scaleY = (containerSize.height - padding * 2) / layout.totalHeight;
    const initialScale = Math.min(scaleX, scaleY, 1.2);

    setTransform({
      x: (containerSize.width - layout.totalWidth * initialScale) / 2,
      y: (containerSize.height - layout.totalHeight * initialScale) / 2,
      scale: initialScale
    });
    userInteractedRef.current = true;
    autoZoomAppliedRef.current = true;
  }
};

// 加载后执行自适应缩放
useEffect(() => {
  if (shouldAutoFitAfterLoadRef.current && layout.totalWidth > 0 && containerSize.width > 0) {
    shouldAutoFitAfterLoadRef.current = false;
    resetViewportOnly();
  }
}, [layout.totalWidth, layout.totalHeight, containerSize.width, containerSize.height]);
```

**结果**：❌ 待解决

### 问题 4：文件占用问题

**现象**：保存时提示文件被占用

**错误信息**：
```
Save failed failed to open file at path: E:\资源\Test.aurora with error: 另一个程序正在使用此文件，进程无法访问。 (os error 32)
```

**可能原因**：
1. 7z 或其他程序正在查看该文件
2. Tauri 的文件写入机制问题
3. 之前的写入操作没有正确关闭文件句柄

**待解决的方案**：
1. 检查是否有其他程序占用文件
2. 使用临时文件写入，然后重命名
3. 添加文件锁检查机制

## 当前状态

- ✅ ZIP 格式存储实现完成
- ✅ 类型定义更新完成
- ✅ 保存/加载逻辑实现完成
- ✅ 向后兼容实现完成
- ✅ 图片读取问题已解决（修复 base64 解码）
- ✅ 文件加载问题已解决（添加 readFile 导入）
- ✅ 加载时画布自适应缩放实现完成
- ⚠️ 文件占用问题需要进一步排查

## 修改的文件

1. `package.json` - 添加 `jszip` 依赖
2. `src/components/comparer/types.ts` - 添加新类型定义
3. `src/components/ImageComparer.tsx` - 更新保存和加载逻辑
   - 修复 base64 解码问题（处理 Data URL 格式）
   - 添加 `readFile` 导入
   - 实现加载时画布自适应缩放
4. `src-tauri/capabilities/default.json` - 更新权限配置

## 本次会话完成的修改

### 修复 1：base64 解码问题
- **文件**：`src/components/ImageComparer.tsx`
- **问题**：Rust 后端返回 Data URL 格式（`data:image/png;base64,xxxx`），但前端直接使用 `atob()` 解码导致错误
- **修复**：提取纯 base64 部分再解码

### 修复 2：readFile 未定义
- **文件**：`src/components/ImageComparer.tsx`
- **问题**：使用了 `readFile` 但没有导入
- **修复**：添加 `readFile` 到 import 语句

### 修复 3：加载时画布自适应缩放
- **文件**：`src/components/ImageComparer.tsx`
- **问题**：加载后画布没有自适应窗口
- **修复**：
  - 创建 `resetViewportOnly()` 函数
  - 添加 `shouldAutoFitAfterLoadRef` 标记
  - 使用 useEffect 在 layout 更新后执行自适应缩放

## 下一步工作

1. 解决文件读取权限问题，确保 Rust 后端命令可以正常读取任意路径的图片
2. 解决文件占用问题，确保可以正常写入 `.aurora` 文件
3. 测试 ZIP 文件的压缩率和加载性能
4. 添加错误处理和用户提示
