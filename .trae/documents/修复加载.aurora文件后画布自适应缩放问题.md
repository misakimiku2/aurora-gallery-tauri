## 问题分析

从截图可以看到，加载 `.aurora` 文件后图片显示在画布左侧并部分超出可视区域。

### 根本原因

1. `layout` 计算中，当存在 `manualLayouts` 时，图片位置使用 `manual.x/manual.y`，但 `totalWidth/totalHeight` 仍基于原始紧凑布局计算
2. `resetViewportOnly` 使用错误的 `layout.totalWidth/totalHeight` 计算自适应缩放
3. 保存的坐标可能是相对于原点的绝对坐标，但自适应计算没有正确考虑图片的实际边界

### 修复方案

修改 `resetViewportOnly` 函数（第 1458-1473 行），使其：

1. 基于 `layout.items` 中所有图片的实际位置计算边界框（bounding box）
2. 使用实际边界计算缩放比例和居中位置
3. 确保加载后画布内容能正确适应窗口

### 代码修改

```typescript
// 只重置画布视图，不重置图片变换
const resetViewportOnly = () => {
  if (layout.items.length === 0 || containerSize.width === 0) return;
  
  // 计算所有图片的实际边界框
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  layout.items.forEach(item => {
    minX = Math.min(minX, item.x);
    minY = Math.min(minY, item.y);
    maxX = Math.max(maxX, item.x + item.width);
    maxY = Math.max(maxY, item.y + item.height);
  });
  
  const contentWidth = maxX - minX;
  const contentHeight = maxY - minY;
  
  if (contentWidth <= 0 || contentHeight <= 0) return;
  
  const padding = 60;
  const scaleX = (containerSize.width - padding * 2) / contentWidth;
  const scaleY = (containerSize.height - padding * 2) / contentHeight;
  const initialScale = Math.min(scaleX, scaleY, 1.2);

  // 计算居中位置：让内容边界框居中显示
  const contentCenterX = minX + contentWidth / 2;
  const contentCenterY = minY + contentHeight / 2;
  
  setTransform({
    x: containerSize.width / 2 - contentCenterX * initialScale,
    y: containerSize.height / 2 - contentCenterY * initialScale,
    scale: initialScale
  });
  userInteractedRef.current = true;
  autoZoomAppliedRef.current = true;
};
```

这个修改确保自适应缩放基于图片的实际位置，而不是可能不准确的 `totalWidth/totalHeight`。