## 问题分析
当前 `ImageComparer` 组件在处理多张 4K 分辨率大图时，缩放和拖拽会出现卡顿和掉帧。主要瓶颈包括：

1. **图片缓存不足**：只创建了 0.25 倍缩小版本，中等缩放时仍需绘制完整原图
2. **缺乏视口裁剪**：无论图片是否在可视区域内都会绘制
3. **滚轮缩放频繁重绘**：每一帧都重绘所有图片
4. **拖拽时持续重绘**：中键拖拽过程中不断触发 Canvas 重绘

## 优化方案

### 1. 多级 Mipmap 缓存系统
- 创建 4 个缩放级别的缓存：1.0 (原图)、0.5、0.25、0.125
- 根据当前缩放比例自动选择最合适的缓存级别
- 放大到 100% 以上时直接显示原图
- 缩小时使用预渲染的低分辨率缓存，减少像素处理量

### 2. 视口裁剪 (Viewport Culling)
- 计算每张图片的 AABB (轴对齐包围盒)
- 只绘制与可视区域相交的图片
- 大幅减少绘制调用次数，特别是缩小时

### 3. 滚轮缩放优化 - CSS Transform 硬件加速
- 滚轮事件触发时，使用 CSS `transform` 对 Canvas 进行缩放/平移
- 利用 GPU 硬件加速，实现 60fps 流畅预览
- 缩放动画结束后再进行 Canvas 重绘
- 用户将看到流畅的缩放过程，没有加载痕迹

### 4. 拖拽优化 - 分离渲染与交互
- 中键拖拽时，使用 CSS `transform` 移动 Canvas
- 拖拽过程中不进行任何 Canvas 重绘
- 拖拽结束 (mouseup) 后再更新 Canvas 内容
- 解决"缩小到最小时拖拽卡顿"的问题

### 5. 离屏 Canvas 缓存
- 创建与可视区域等大的离屏 Canvas
- 将图片绘制到离屏 Canvas 缓存
- transform 变化时直接复制离屏 Canvas，无需重绘所有图片
- 仅在图片数据变化时才需要重绘

## 实施步骤

1. **重构图片缓存结构**：从 `{ original, small }` 改为多级缓存
2. **添加 CSS transform 状态管理**：区分 "视觉变换" 和 "逻辑变换"
3. **实现视口裁剪函数**：计算可见图片集合
4. **修改滚轮事件处理**：使用 CSS transform 动画
5. **修改拖拽逻辑**：拖拽时只更新 CSS transform
6. **优化 Canvas 绘制**：使用离屏缓存 + 视口裁剪

## 预期效果

- **放大到原图**：直接显示原图，清晰无模糊
- **缩小拖拽**：60fps 流畅，无卡顿
- **滚轮缩放**：平滑流畅，无加载痕迹
- **内存占用**：通过多级缓存平衡内存与性能