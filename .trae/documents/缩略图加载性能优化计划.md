# 缩略图读取性能优化计划

## 问题分析
通过分析代码库，我发现即使缩略图已经生成，当前读取流程仍存在以下性能瓶颈：

1. **不必要的数据库操作**：每次调用 `get_thumbnails_batch` 都会将文件添加到数据库
2. **颜色提取开销**：即使只需要读取缩略图，仍会执行颜色提取操作
3. **API 调用开销**：大量文件的 API 调用增加了网络和处理开销
4. **前端缓存策略**：瀑布流视图中缓存命中率可能不高
5. **缺乏预加载机制**：没有提前加载即将可见的图片

## 优化方案

### 1. 优化后端读取流程
- **修改文件**：`src-tauri/src/main.rs:1385-1489`
- **优化内容**：
  - 移除不必要的数据库操作，只在需要时进行
  - 分离缩略图读取和颜色提取逻辑
  - 对于已存在的缓存文件，直接返回路径，跳过不必要的处理
  - 实现快速路径，减少函数调用层级
- **预期效果**：减少后端处理时间，提高 API 响应速度

### 2. 改进前端缓存策略
- **修改文件**：`src/components/FileGrid.tsx:458-496`
- **优化内容**：
  - 增加缓存预加载机制，提前加载即将可见的图片
  - 优化缓存键的生成，提高缓存命中率
  - 增加缓存的内存限制，避免过多占用内存
- **预期效果**：提高前端缓存命中率，减少 API 请求

### 3. 实现请求批处理优化
- **修改文件**：`src/api/tauri-bridge.ts:144-275`
- **优化内容**：
  - 调整批处理延迟，减少请求等待时间
  - 实现基于文件路径的缓存检查，避免重复请求
  - 为已缓存的文件实现快速返回机制
- **预期效果**：减少批处理等待时间，提高响应速度

### 4. 实现可见性优先加载
- **修改文件**：`src/components/FileGrid.tsx`
- **优化内容**：
  - 使用 Intersection Observer 检测可见区域
  - 优先加载可见区域的图片
  - 延迟加载不可见区域的图片
  - 实现请求取消机制，避免不必要的请求
- **预期效果**：提高可见区域图片的加载速度，减少后端负载

### 5. 优化颜色提取逻辑
- **修改文件**：`src-tauri/src/main.rs:1385-1489`
- **优化内容**：
  - 将颜色提取移到单独的异步任务中
  - 只在需要时进行颜色提取
  - 避免阻塞缩略图返回
- **预期效果**：减少单个请求的响应时间，提高前端渲染速度

## 预期效果

1. **缩略图读取时间**：从300-500ms减少到50-100ms
2. **API 请求次数**：减少50%以上
3. **前端缓存命中率**：提高到80%以上
4. **用户体验**：瀑布流滚动更加流畅，图片加载更快

## 实现步骤

1. 首先优化后端读取流程，减少不必要的处理步骤
2. 然后改进前端缓存策略，提高缓存命中率
3. 接着实现可见性优先加载，优化用户体验
4. 最后优化颜色提取逻辑，进一步减少响应时间

每个优化步骤都会进行测试，确保性能提升符合预期。