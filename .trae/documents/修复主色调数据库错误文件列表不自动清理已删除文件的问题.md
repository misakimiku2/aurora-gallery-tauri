## 问题描述
用户在文件管理器中手动删除了损坏的文件，但主色调数据库中的错误文件记录没有同步更新。点击刷新按钮后仍然显示已删除的文件（85个错误文件）。

## 解决方案

### 1. 后端修改

#### `src-tauri/src/color_db.rs`
添加一个新函数 `cleanup_nonexistent_error_files`，用于：
- 获取所有状态为 error 的文件记录
- 检查每个文件是否实际存在
- 删除不存在文件的记录
- 返回实际存在的错误文件列表

#### `src-tauri/src/main.rs`
修改 `get_color_db_error_files` 命令：
- 在返回错误文件列表前，先调用清理函数
- 只返回实际存在的错误文件

### 2. 前端修改（可选增强）

#### `src/components/SettingsModal.tsx`
- 在错误文件管理区域添加提示信息，说明刷新时会自动清理无效记录
- 保持现有功能不变

## 实现细节

### 后端代码修改

**`color_db.rs` 新增函数：**
```rust
// 清理不存在的错误文件记录，返回实际存在的错误文件列表
pub fn cleanup_nonexistent_error_files(
    conn: &mut Connection
) -> Result<Vec<(String, i64)>> {
    let error_files = get_error_files(conn)?;
    let mut existing_files = Vec::new();
    let mut nonexistent_paths = Vec::new();
    
    for (path, timestamp) in error_files {
        if std::path::Path::new(&path).exists() {
            existing_files.push((path, timestamp));
        } else {
            nonexistent_paths.push(path);
        }
    }
    
    // 删除不存在的文件记录
    if !nonexistent_paths.is_empty() {
        delete_error_files(conn, &nonexistent_paths)?;
        eprintln!("Cleaned up {} non-existent error file records", nonexistent_paths.len());
    }
    
    Ok(existing_files)
}
```

**`main.rs` 修改命令：**
```rust
#[tauri::command]
async fn get_color_db_error_files(app: tauri::AppHandle) -> Result<Vec<serde_json::Value>, String> {
    let pool = app.state::<Arc<color_db::ColorDbPool>>().inner().clone();
    
    let result = tokio::task::spawn_blocking(move || {
        let mut conn = pool.get_connection();
        // 使用新的清理函数，自动删除不存在的文件记录
        let error_files = color_db::cleanup_nonexistent_error_files(&mut conn)
            .unwrap_or_default();
        
        error_files.into_iter().map(|(path, timestamp)| {
            serde_json::json!({
                "path": path,
                "timestamp": timestamp
            })
        }).collect::<Vec<_>>()
    }).await.map_err(|e| format!("Failed to get error files: {}", e))?;
    
    Ok(result)
}
```

## 预期效果
- 用户点击刷新按钮时，会自动检测并清理已不存在的文件记录
- 错误文件数量会正确反映实际存在的损坏文件数量
- 不需要手动逐个删除数据库记录