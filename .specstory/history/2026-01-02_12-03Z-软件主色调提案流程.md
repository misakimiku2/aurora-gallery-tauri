<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session e492e80a-aec6-419c-9d84-4a81a77e4502 (2026-01-02 12:03Z) -->

# 软件主色调提案流程 (2026-01-02 12:03Z)

_**User (2026-01-02 10:50Z)**_

当前软件的主色调提起流程步骤是怎么样的？

---

_**Agent (model default, mode Ask)**_



---


查找颜色提取相关代码，梳理主色调提取流程。


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src-tauri/src/color_extractor.rs</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src-tauri/src/color_worker.rs</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src-tauri/src/color_db.rs</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** • Searched codebase "How is color extraction called or triggered in the frontend?" • **2** results</summary>
            
| File | Lines |
|------|-------|
| `src/components/MetadataPanel.tsx` | L208-1600 |
| `src/App.tsx` | L336-5996 |

</details>
</tool-use>

---



---


查看前端如何调用颜色提取，以及主程序如何启动该流程：


---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "getDominantColors" in "src" • 5 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `src\api\tauri-bridge.ts` | `export const getDominantColors = async (filePath: string, count: number = 8, thumbnailPath?: string): Promise<DominantColor[]> => \{` | L574 |
| `src\components\MetadataPanel.tsx` | `const \{ getDominantColors \} = await import('../api/tauri-bridge');` | L323 |
| `src\components\MetadataPanel.tsx` | `const colors = await getDominantColors(file.path!, 8, thumbnailPath \|\| undefined);` | L353 |
| `src\components\MetadataPanel.tsx` | `const \{ getDominantColors \} = await import('../api/tauri-bridge');` | L966 |
| `src\components\MetadataPanel.tsx` | `const colors = await getDominantColors(file.path!, 8, thumbnailPath \|\| undefined);` | L988 |


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/api/tauri-bridge.ts</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "color_extraction_worker|add_pending_files" in "src-tauri/src" • 6 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `src-tauri/src\main.rs` | `color_db::add_pending_files(&mut conn, &chunk_vec)` | L474 |
| `src-tauri/src\main.rs` | `color_db::add_pending_files(&mut conn, &[image_path])` | L616 |
| `src-tauri/src\main.rs` | `let _ = color_db::add_pending_files(&mut conn, &[file_path_clone.clone()]);` | L1808 |
| `src-tauri/src\main.rs` | `color_worker::color_extraction_worker(` | L1948 |
| `src-tauri/src\color_worker.rs` | `pub async fn color_extraction_worker(` | L47 |
| `src-tauri/src\color_db.rs` | `pub fn add_pending_files(conn: &mut Connection, file_paths: &[String]) -> Result<()> \{` | L76 |


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src-tauri/src/main.rs</summary>

</details>
</tool-use>

---



---


主色调提取流程如下：

## 主色调提取流程步骤

### 1. **文件注册阶段**

当扫描目录或单个文件时，系统会将图片路径添加到颜色数据库：

```454:483:src-tauri/src/main.rs
    // Collect all image paths from the scan results
    let image_paths: Vec<String> = all_files
        .iter()
        .filter(|(_, node)| matches!(node.r#type, FileType::Image))
        .map(|(_, node)| node.path.clone())
        .collect();
    
    // Add all image paths to color database in batches
    if !image_paths.is_empty() {
        let pool = app.state::<Arc<color_db::ColorDbPool>>().inner().clone();
        let batch_size = 100;
        
        // Process in batches to avoid database overload
        for chunk in image_paths.chunks(batch_size) {
            let chunk_vec: Vec<String> = chunk.iter().cloned().collect();
            let pool_clone = pool.clone();
            
            // Add to database in a blocking thread
            let result = tokio::task::spawn_blocking(move || {
                let mut conn = pool_clone.get_connection();
                color_db::add_pending_files(&mut conn, &chunk_vec)
            }).await;
            
            if let Err(e) = result {
                eprintln!("Failed to add batch to color database: {}", e);
            } else if let Err(e) = result.unwrap() {
                eprintln!("Database error when adding batch: {}", e);
            }
        }
    }
```

文件被标记为 `"pending"` 状态，等待处理。

### 2. **后台工作器启动**

应用启动时，后台工作器自动启动：

```1940:1953:src-tauri/src/main.rs
            // 启动后台颜色提取任务
            // 持续处理待处理文件，每批最多处理20个文件
            let batch_size = 20;
            // 正确克隆AppHandle后再包装到Arc中
            let app_handle_new = app.handle().clone();
            let app_handle_arc = Arc::new(app_handle_new);
            
            tauri::async_runtime::spawn(async move {
                color_worker::color_extraction_worker(
                    pool_arc,
                    batch_size,
                    Some(app_handle_arc)
                ).await;
            });
```

### 3. **批量处理流程**

后台工作器持续循环处理待处理文件：

```63:88:src-tauri/src/color_worker.rs
    loop {
        // 检查是否暂停
        if is_paused() {
            tokio::time::sleep(Duration::from_millis(500)).await;
            continue;
        }
        
        // 处理一批待处理文件
        let pool_clone = pool.clone();
        let app_handle_clone = app_handle.clone();
        let current_file_clone = current_file.clone();
        
        if let Err(e) = process_pending_files(
            pool_clone, 
            batch_size, 
            &thread_pool, 
            app_handle_clone,
            current_file_clone
        ).await {
            eprintln!("Error processing pending files: {}", e);
        }
        
        // 短暂睡眠，避免CPU空转
        tokio::time::sleep(Duration::from_millis(100)).await;
    }
```

### 4. **单个文件处理步骤**

对每个文件执行以下步骤：

#### 4.1 加载和缩放图片
```156:182:src-tauri/src/color_worker.rs
                // 1. 加载和处理图片（同步操作）
                let img_result: Result<image::DynamicImage, String> = {
                    let file = File::open(&file_path_sync)
                        .map_err(|e| format!("Failed to open file: {}", e))?;
                    
                    let reader = BufReader::new(file);
                    let mut img = image::load(reader, ImageFormat::from_path(&file_path_sync).unwrap_or(ImageFormat::Jpeg))
                        .map_err(|e| format!("Failed to load image: {}", e))?;
                    
                    // 等比例缩小图片到256px，以较小边为准
                    let (width, height) = img.dimensions();
                    let max_dim = 256;
                    
                    if width > max_dim || height > max_dim {
                        let (new_width, new_height) = if width < height {
                            let scale = max_dim as f32 / width as f32;
                            (max_dim, (height as f32 * scale) as u32)
                        } else {
                            let scale = max_dim as f32 / height as f32;
                            ((width as f32 * scale) as u32, max_dim)
                        };
                        
                        img = img.resize_exact(new_width, new_height, image::imageops::FilterType::Triangle);
                    }
                    
                    Ok(img)
                };
```

#### 4.2 调用颜色提取算法
```185:185:src-tauri/src/color_worker.rs
                let colors = color_extractor::get_dominant_colors(&img, 8);
```

### 5. **颜色提取核心算法**

`get_dominant_colors` 函数执行以下步骤：

#### 5.1 像素预过滤
```20:39:src-tauri/src/color_extractor.rs
    // 2. 执行像素预过滤
    let filtered_pixels: Vec<u8> = rgba_img
        .pixels()
        .filter_map(|p| {
            let [r, g, b, a] = p.0;

            // 条件 A: 过滤透明像素 (Alpha < 125)
            if a < 125 {
                return None;
            }

            // 条件 B: 过滤接近白色的像素 (R,G,B 均 > 250)
            if r > 250 && g > 250 && b > 250 {
                return None;
            }

            Some(vec![r, g, b])
        })
        .flatten()
        .collect();
```

#### 5.2 使用 ColorThief 算法提取
```45:53:src-tauri/src/color_extractor.rs
    // 3. 调用 ColorThief 算法提取颜色
    // 使用采样步长1（采样所有像素）以确保不会遗漏明显的颜色，特别是小区域的明显颜色如红色
    // 提取稍多一些颜色(16个)以确保有足够的候选，包括鲜艳的小面积颜色
    let request_count = (count + 8).min(20).max(count);
    let count_u8 = request_count.min(255) as u8;
    let palette = match get_palette(&filtered_pixels, ColorFormat::Rgb, 1, count_u8) {
        Ok(p) => p,
        Err(_) => return Vec::new(),
    };
```

#### 5.3 颜色评分和排序
```55:91:src-tauri/src/color_extractor.rs
    // 4. 改进的颜色选择逻辑：考虑颜色的频率为主，饱和度为辅
    // 为每个颜色计算饱和度，并按频率和饱和度的综合评分排序
    let mut colored_palette: Vec<_> = palette
        .iter()
        .enumerate()
        .map(|(index, color)| {
            // 计算 RGB 值的浮点表示 (0.0-1.0)
            let r = color.r as f32 / 255.0;
            let g = color.g as f32 / 255.0;
            let b = color.b as f32 / 255.0;
            
            // 计算颜色的亮度
            let luminance = 0.299 * r + 0.587 * g + 0.114 * b;
            
            // 计算颜色的最大值和最小值
            let max = r.max(g).max(b);
            let min = r.min(g).min(b);
            
            // 计算饱和度
            let saturation = if max == min {
                0.0
            } else {
                (max - min) / (1.0 - (2.0 * luminance - 1.0).abs())
            };
            
            // 综合评分：频率权重(0.8) + 饱和度权重(0.2)
            // 降低指数衰减的频率权重，确保占比高的颜色（如深色头发）仍然有最高权重
            // 这样可以确保占比最多的#3D3634颜色不会被忽略
            let frequency_weight = 1.0 / ((index as f32 + 1.0).powf(0.25));
            let score = (frequency_weight * 0.8) + (saturation * 0.2);
            
            (color, saturation, luminance, score)
        })
        .collect();
    
    // 5. 按综合评分排序，确保占比高的颜色有最高排名，同时兼顾鲜艳度
    colored_palette.sort_by(|a, b| b.3.partial_cmp(&a.3).unwrap_or(std::cmp::Ordering::Equal));
```

#### 5.4 颜色去重和格式化
```93:159:src-tauri/src/color_extractor.rs
    // 6. 格式化所有颜色并返回前count个，同时确保颜色多样性
    // 简单去重：确保返回的颜色之间有足够的差异
    let mut result = Vec::new();
    let mut added_colors: Vec<[u8; 3]> = Vec::new();
    
    for (color, _, _, _) in &colored_palette {
        if result.len() >= count {
            break;
        }
        
        // 检查与已添加颜色的差异
        let new_rgb = [color.r, color.g, color.b];
        let mut is_unique = true;
        
        for existing in &added_colors {
            // 计算颜色差异
            let diff = (
                (new_rgb[0] as i32 - existing[0] as i32).abs() +
                (new_rgb[1] as i32 - existing[1] as i32).abs() +
                (new_rgb[2] as i32 - existing[2] as i32).abs()
            ) as u32;
            
            // 如果差异太小，跳过这个颜色
            if diff < 30 {
                is_unique = false;
                break;
            }
        }
        
        if is_unique {
            let hex = format!("#{:02x}{:02x}{:02x}", color.r, color.g, color.b);
            let luminance = 0.299 * color.r as f32 + 0.587 * color.g as f32 + 0.114 * color.b as f32;
            let is_dark = luminance < 128.0;
            
            result.push(ColorResult {
                hex,
                rgb: [color.r, color.g, color.b],
                is_dark,
            });
            
            added_colors.push(new_rgb);
        }
    }
    
    // 如果去重后颜色数量不足，补充一些原始颜色
    if result.len() < count {
        for (color, _, _, _) in &colored_palette {
            if result.len() >= count {
                break;
            }
            
            let hex = format!("#{:02x}{:02x}{:02x}", color.r, color.g, color.b);
            let luminance = 0.299 * color.r as f32 + 0.587 * color.g as f32 + 0.114 * color.b as f32;
            let is_dark = luminance < 128.0;
            
            // 检查是否已经添加
            if !result.iter().any(|c| c.hex == hex) {
                result.push(ColorResult {
                    hex,
                    rgb: [color.r, color.g, color.b],
                    is_dark,
                });
            }
        }
    }
```

### 6. **保存到数据库**

提取完成后，将结果保存到数据库并更新状态：

```197:200:src-tauri/src/color_worker.rs
                // 保存到数据库
                let mut conn = pool_sync.get_connection();
                color_db::save_colors(&mut conn, &file_path_sync, &colors)
                    .map_err(|e| format!("Failed to save colors: {}", e))?;
```

### 7. **前端调用（可选）**

前端也可以主动调用颜色提取 API：

```574:582:src/api/tauri-bridge.ts
export const getDominantColors = async (filePath: string, count: number = 8, thumbnailPath?: string): Promise<DominantColor[]> => {
  try {
    const result = await invoke('get_dominant_colors', { filePath, count, thumbnailPath });
    return result as DominantColor[];
  } catch (error) {
    console.error('Failed to get dominant colors:', error);
    return [];
  }
};
```

该 API 会先查询数据库，如果没有数据则实时提取。

## 总结

整个流程是异步后台处理：
1. 扫描时自动注册图片到数据库
2. 后台工作器批量并行处理（使用 CPU 核心数的一半）
3. 每个文件经过：加载→缩放→过滤→ColorThief 提取→评分排序→去重→保存
4. 前端可通过 API 实时获取或触发提取
5. 支持暂停/恢复控制

该设计可在后台处理大量图片，同时不影响前端性能。

---

_**User (2026-01-02 10:50Z)**_

目前在生成这个主色调的时候太慢了，一张图大概需要1-3秒左右。有没有什么方案可以加快提升的？

---

_**Agent (model default, mode Ask)**_



---


分析性能瓶颈，查找可优化点：


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src-tauri/src/color_extractor.rs</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src-tauri/src/color_worker.rs</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** • Searched codebase "How is image loading and resizing optimized for performance?" • **14** results</summary>
            
| File | Lines |
|------|-------|
| `src-tauri/src/main.rs` | L627-688 |
| `src/components/ImageViewer.tsx` | L45-885 |
| `src-tauri/src/main.rs` | L521-576 |
| `src-tauri/src/main.rs` | L572-631 |
| `src/components/FileGrid.tsx` | L24-195 |
| `src/components/MetadataPanel.tsx` | L4-75 |
| `src/components/FileGrid.tsx` | L24-209 |
| `src-tauri/Cargo.toml` | L36 |
| `src/components/MetadataPanel.tsx` | L63-150 |
| `src/App.tsx` | L336-5996 |
| `src/api/tauri-bridge.ts` | L123-274 |
| `src-tauri/src/main.rs` | L75 |
| `src/App.tsx` | L293-684 |
| `src/App.tsx` | L295-684 |

</details>
</tool-use>

---



---


分析性能瓶颈，提出优化方案：

主要瓶颈：
1. 图片加载和缩放：大图完整加载后缩放到256px
2. 像素采样：ColorThief 使用步长1，处理所有像素
3. 像素过滤：遍历所有像素进行过滤
4. 缩放算法：Triangle 质量好但较慢

优化方案：


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src-tauri/Cargo.toml</summary>

</details>
</tool-use>

---



---


优化方案如下：

## 优化方案

### 方案1：缩小图片尺寸（最快，效果明显）

将处理尺寸从256px降到128px或更小，可显著减少处理像素数：

```rust
// src-tauri/src/color_worker.rs
// 在 process_pending_files 函数中，修改缩放尺寸
// 等比例缩小图片到128px（从256px降低），以较小边为准
let (width, height) = img.dimensions();
let max_dim = 128; // 从 256 改为 128，减少4倍像素数

if width > max_dim || height > max_dim {
    let (new_width, new_height) = if width < height {
        let scale = max_dim as f32 / width as f32;
        (max_dim, (height as f32 * scale) as u32)
    } else {
        let scale = max_dim as f32 / height as f32;
        ((width as f32 * scale) as u32, max_dim)
    };
    
    // 使用更快的缩放算法
    img = img.resize_exact(new_width, new_height, image::imageops::FilterType::Linear); // 从 Triangle 改为 Linear
}
```

### 方案2：增加像素采样步长（减少处理量）

在 ColorThief 中增加采样步长，跳过部分像素：

```rust
// src-tauri/src/color_extractor.rs
// 修改 get_dominant_colors 函数
pub fn get_dominant_colors(img: &DynamicImage, count: usize) -> Vec<ColorResult> {
    let rgba_img = img.to_rgba8();
    let (width, height) = rgba_img.dimensions();
    
    // 2. 执行像素预过滤，使用步长采样（从每像素改为每2-3像素）
    let step = if width * height > 10000 { 3 } else { 2 }; // 大图用步长3，小图用步长2
    let filtered_pixels: Vec<u8> = (0..height)
        .step_by(step)
        .flat_map(|y| {
            (0..width)
                .step_by(step)
                .filter_map(|x| {
                    let pixel = rgba_img.get_pixel(x, y);
                    let [r, g, b, a] = pixel.0;

                    // 条件 A: 过滤透明像素
                    if a < 125 {
                        return None;
                    }

                    // 条件 B: 过滤接近白色的像素
                    if r > 250 && g > 250 && b > 250 {
                        return None;
                    }

                    Some(vec![r, g, b])
                })
        })
        .flatten()
        .collect();

    if filtered_pixels.is_empty() {
        return Vec::new();
    }

    // 3. 调用 ColorThief 算法，减少请求的颜色数量
    let request_count = (count + 4).min(12).max(count); // 从 +8.min(20) 改为 +4.min(12)
    let count_u8 = request_count.min(255) as u8;
    let palette = match get_palette(&filtered_pixels, ColorFormat::Rgb, 1, count_u8) {
        Ok(p) => p,
        Err(_) => return Vec::new(),
    };
    
    // ... 其余代码保持不变
}
```

### 方案3：使用缩略图而非原图（最佳）

如果已有缩略图，直接使用缩略图提取颜色：

```rust
// src-tauri/src/color_worker.rs
// 修改 process_pending_files，优先使用缩略图
async fn process_pending_files(
    pool: Arc<ColorDbPool>, 
    batch_size: usize,
    _thread_pool: &rayon::ThreadPool,
    app_handle: Option<Arc<AppHandle>>,
    current_file: Arc<Mutex<String>>,
    cache_root: Option<String> // 新增参数
) -> Result<(), String> {
    // ... 获取待处理文件列表的代码 ...
    
    let results: Vec<_> = {
        _thread_pool.install(|| {
            pending_files.into_iter().map(|file_path: String| {
                // 1. 优先尝试使用缩略图
                let image_path = if let Some(cache_root) = &cache_root {
                    // 计算缩略图路径（复用缩略图生成的逻辑）
                    let cache_key = /* 计算缓存key */;
                    let cache_filename = format!("{:x}", md5::compute(cache_key.as_bytes()))[..24].to_string();
                    let thumb_path = Path::new(cache_root).join(format!("{}.jpg", cache_filename));
                    
                    if thumb_path.exists() {
                        thumb_path.to_str().unwrap().to_string()
                    } else {
                        file_path.clone()
                    }
                } else {
                    file_path.clone()
                };
                
                // 2. 加载图片（如果使用缩略图，可能不需要缩放）
                let img_result: Result<image::DynamicImage, String> = {
                    let file = File::open(&image_path)
                        .map_err(|e| format!("Failed to open file: {}", e))?;
                    
                    let reader = BufReader::new(file);
                    let mut img = image::load(reader, ImageFormat::from_path(&image_path).unwrap_or(ImageFormat::Jpeg))
                        .map_err(|e| format!("Failed to load image: {}", e))?;
                    
                    // 如果使用缩略图且尺寸已经很小，跳过缩放
                    let (width, height) = img.dimensions();
                    if width > 128 || height > 128 {
                        let max_dim = 128;
                        let (new_width, new_height) = if width < height {
                            let scale = max_dim as f32 / width as f32;
                            (max_dim, (height as f32 * scale) as u32)
                        } else {
                            let scale = max_dim as f32 / height as f32;
                            ((width as f32 * scale) as u32, max_dim)
                        };
                        
                        img = img.resize_exact(new_width, new_height, image::imageops::FilterType::Linear);
                    }
                    
                    Ok(img)
                };
                
                // ... 其余代码保持不变
            })
        })
    };
    
    // ... 其余代码
}
```

### 方案4：优化像素过滤（使用并行处理）

使用 rayon 并行处理像素过滤：

```rust
// src-tauri/src/color_extractor.rs
use rayon::prelude::*;

pub fn get_dominant_colors(img: &DynamicImage, count: usize) -> Vec<ColorResult> {
    let rgba_img = img.to_rgba8();
    let (width, height) = rgba_img.dimensions();
    
    // 2. 使用并行处理像素过滤
    let step = if width * height > 10000 { 3 } else { 2 };
    let filtered_pixels: Vec<u8> = (0..height)
        .step_by(step)
        .into_par_iter() // 并行迭代
        .flat_map(|y| {
            (0..width)
                .step_by(step)
                .filter_map(|x| {
                    let pixel = rgba_img.get_pixel(x, y);
                    let [r, g, b, a] = pixel.0;

                    if a < 125 || (r > 250 && g > 250 && b > 250) {
                        return None;
                    }

                    Some(vec![r, g, b])
                })
        })
        .flatten()
        .collect();
    
    // ... 其余代码
}
```

### 方案5：简化颜色评分逻辑（减少计算）

简化评分计算，减少浮点运算：

```rust
// src-tauri/src/color_extractor.rs
// 简化评分计算，使用整数运算
let mut colored_palette: Vec<_> = palette
    .iter()
    .enumerate()
    .map(|(index, color)| {
        // 使用整数运算代替浮点运算
        let r = color.r as u32;
        let g = color.g as u32;
        let b = color.b as u32;
        
        // 简化的亮度计算（避免浮点）
        let luminance = (r * 299 + g * 587 + b * 114) / 1000;
        
        // 简化的饱和度计算
        let max = r.max(g).max(b);
        let min = r.min(g).min(b);
        let saturation = if max == min { 0 } else { ((max - min) * 100) / max };
        
        // 简化的评分（使用整数）
        let frequency_weight = 1000 / ((index + 1) * 2); // 简化计算
        let score = (frequency_weight * 8 + saturation * 2) / 10; // 整数运算
        
        (color, saturation, luminance, score)
    })
    .collect();
```

## 推荐实施顺序

1. 方案1：缩小到128px + 使用Linear缩放（最快，约提升2-3倍）
2. 方案2：增加采样步长（约再提升1.5-2倍）
3. 方案3：使用缩略图（如果已有，可再提升）
4. 方案4：并行处理（多核CPU下额外提升）
5. 方案5：简化计算（小幅提升）

## 预期效果

- 方案1+2：从1-3秒降至0.3-0.8秒（约3-5倍）
- 方案1+2+3：如果已有缩略图，可降至0.1-0.3秒（约5-10倍）
- 全部实施：预计可降至0.1-0.5秒

需要我生成完整的优化代码吗？

---

_**User (2026-01-02 10:50Z)**_

使用缩略图的方案一开始有考虑过，这个好像也集成进去了，但是一般来说这个主色调会更优先于缩略图，因为主色调在一开始就会进行生成，而缩略图则是需要点击进入文件夹或者是手动生成

---

_**Agent (model default, mode Ask)**_



---

