### 优化分析

目前的实现会将整个颜色数据库加载到内存中（`ColorDbPool.cache`）以确保搜索的高性能。缓存的结构体（`CachedImage`）包含：

1. `file_path` (`String`): 文件路径。
2. `colors` (`Vec<String>`): 十六进制颜色字符串列表（例如 `"#FF0000"`）。
3. `labs` (`Vec<Lab>`): 解析后的 Lab 颜色值列表（用于感知颜色差异计算）。

## 冗余点：

- 搜索算法__（main.rs中的search_by_palette）仅使用labs字段和file_path。
- `colors`（十六进制字符串）字段在搜索或结果生成过程中从未被使用（结果仅返回文件路径)。
- 对于 68,000 多张图片，每个 `colors` 向量都会增加显著的开销（字符串分配、向量元数据）。

## 预计节省内存：
- 通过从内存缓存中移除未使用的 `colors` 字段，每张图片大约可以节省180-200 字节。
    - 对于 68,000 张图片，这将减少大约12-14MB的原始结构体内存占用。
    - 考虑到堆分配器的开销和碎片化，实际进程内存的减少将更加显著。
    - 此外，我还发现了未使用的代码（`get_all_completed_colors`），可以将其移除以清理代码库。

### 实施计划
1. 修改 `CachedImage` 结构体__ (`src-tauri/src/color_db.rs`)
   - 移除 `colors: Vec<String>` 字段。
   - 保留 `file_path` 和 `labs`。
2. 重构缓存加载逻辑__ (`src-tauri/src/color_db.rs`)
   - 重构 `load_from_db_internal`（或将其合并到 `refresh_cache` 中），直接将 JSON 解析为 `Vec<Lab>` 并立即丢弃十六进制字符串。
   - 这可以防止在缓存刷新期间分配成千上万个临时的十六进制字符串。
3. 更新缓存操作
   - 更新 `save_colors`、`batch_save_colors` 和 `copy_colors`，以便在向缓存添加新条目时不存储十六进制字符串。
4. 移除死代码
   - 移除未使用的 `get_all_completed_colors` 函数。
   - 移除未使用的 `ImageColors` 结构体（如果不再需要）。
   - 移除未使用的 `delete_colors_by_file_path` 函数。

此更改直接针对“指数级”（实际上是线性但陡峭）的内存增长问题，移除了内存索引中最大的未使用组件。
